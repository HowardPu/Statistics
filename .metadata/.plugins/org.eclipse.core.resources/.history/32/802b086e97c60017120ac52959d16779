package distributions.mass_functions;

public class Poisson extends PMF {
    double lamda;
    
    public Poisson(double frequency) {
    	super(0, Double.POSITIVE_INFINITY);
        if(frequency <= 0) {
            throw new IllegalArgumentException("Invalid frequency : " + frequency);
        }
        lamda = frequency;
    }
    
    public double variance() {
        return lamda;
    }
    
    public double mean() {
        return lamda;
    }
    
    public double median() {
        return lamda + 1.0 / 3 - 0.02 / lamda;
    }
    
    // may not work properly is lamda is too large
    public double mass(int x) {
        double result = Math.exp(-lamda);   
        for(int i = 1; i <= x; i++) {
            result = result * lamda / i;
        }
        return result;
    }
    
    // not work properly if lamda is to large
    public double cumulativeProbability(int lowerBound, int upperBound) {
        if(lowerBound > upperBound) {
            throw new IllegalArgumentException("Illegal bound : lower bound : " + lowerBound + 
                                               " > upper bound : "  + upperBound);
        }
        if(lowerBound < 0 || upperBound < 0) {
            throw new IllegalStateException("bound cannot be less than 0");
        }
        if(upperBound == lowerBound) {
            return mass(upperBound);
        }
        double correction = 0;
        if(upperBound >= lamda * 30) {
            correction++;
            upperBound = (int) (30 * lamda + 1);
        }
        if(lowerBound >= lamda * 30) {
            correction--;
            lowerBound = (int) (30 * lamda + 1);
        }
        return mass(lowerBound) * poissonExpansion(lowerBound, upperBound);
    }
    
    public int inverse(double area) {
        if(area == 0) {
            throw new IllegalStateException("area of a probability mass fuction can not be 0");
        }
        if(area > 1 || area < 0) {
            throw new IllegalArgumentException("invalid area : " + area);
        }
        if(area == 1) {
            return Integer.MAX_VALUE;
        }
        int lowerBound = 0;
        int upperBound = 9999;
        if(area < 0.5) {
            upperBound = (int) median() + 5;
        } else {
            lowerBound = Math.max((int) median() - 5, 0);
        }
        double result = (lowerBound + upperBound) / 2;
        double current = cumulativeProbability(0, (int) result);
        double current2 = cumulativeProbability(0, (int) result + 1);
        while(!(current < area && area < current2)) {
            if(current > area) {
                upperBound = (int) result + 1;
            } else {
                lowerBound = (int) result;
            }
            result = (upperBound + lowerBound) / 2;
            current = cumulativeProbability(0, (int) result);
            current2 = cumulativeProbability(0, (int) result + 1);
        } 
        return (int) result + 1;
    }
    
    private double poissonExpansion(int initial, int end) {
        if(initial + 1 == end) {
            return 1 + lamda / end;
        } else {
            return 1 + lamda / (initial + 1) * poissonExpansion(initial + 1, end);
        }    
    }
}
