package distributions.density_function;

public abstract class PDF extends distributions.DistributionFunction {
    private double lowestBound;
    private double highestBound;
    private boolean isSkew;
    
    public static final double EPSILON = 1E-14;
    
    public PDF(double lowestBound, double highestBound, boolean isSkew) {
        if(lowestBound >= highestBound) {
            throw new IllegalArgumentException("Illegal domain of this distribution");
        }
        this.isSkew = isSkew;
        this.lowestBound = lowestBound;
        this.highestBound = highestBound;
    }
    
    public boolean isSkew() {
    	return isSkew;
    }
    
    public abstract double density(double x);
    
    public double toInfinity(double x) {
        if(isSkew) {
            double complement = cumulativeProbability(lowestBound, x);
            if(complement < 0) {
                return 1;
            } else {
                return Math.max(0, 1 - complement);
            }
        } else {
            if(x < 0) {
                return 1 - toInfinity(-x);
            } else {
                double lowerBound = Math.min(x, mean());
                double upperBound = Math.max(x, mean());
                double complement = 2 * cumulativeProbability(lowerBound, upperBound);
                if(complement > 1) {
                    return 0;
                } else if(complement < 0) {
                    return 1;
                } else {
                    return (1 - complement) / 2;
                }
            }
        }
    }
    
    public double fromNegativeInfinity(double x) {
    	return 1 - toInfinity(x);
    }
    
    public double cumulativeProbability(double lowerBound, double upperBound) {
        if(lowerBound > upperBound) {
            throw new IllegalStateException("Illegal bound : lower bound : " + lowerBound + 
                                               " > upper bound : "  + upperBound);
        }
        if(lowerBound < lowestBound || upperBound > highestBound) {
            throw new IllegalStateException();
        }
        if(lowerBound == upperBound) {
            return 0;
        } else {
            double result = integral(upperBound) - integral(lowerBound);
            if(result > 1) {
                return 1;
            } else {
                return Math.max(result, 0);
            }
        }
    }
    
    public abstract double integral(double x);
    
    public abstract double inverse(double area);
    
    public double inverse(double low, double high, double area) {
        if(area < 0 || area > 1) {
            throw new IllegalArgumentException("Illeagl area : " + area);
        }   
        if(area == 1) {
            return highestBound;
        } else if(area == 0) {
            return lowestBound;
        } else {
            double currentLow = low;
            double result = (currentLow + high) / 2;
            double currentArea = cumulativeProbability(low, result);
            while(Math.abs(area - currentArea) > EPSILON) {
                if(currentArea > area) {
                    high = result;
                } else {
                    currentLow = result;
                }
                result = (high + currentLow) / 2;
                currentArea = cumulativeProbability(low, result);
            }
            return result;
        } 
    }
}